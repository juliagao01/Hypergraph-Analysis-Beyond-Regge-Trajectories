(* Unified Regge-Hypergraph Analysis Plots *)
(* Generated by Python unified analysis framework *)

(* Load the exported data *)
<< "unified_states.m"
<< "regge_fit_results.m"
<< "bridging_analysis_results.m"
<< "hypothesis_test_results.m"
<< "predictions.m"

(* Set up plotting styles *)
SetOptions[Plot, 
  BaseStyle -> {FontFamily -> "Times", FontSize -> 12},
  FrameStyle -> Directive[Black, Thick],
  GridLines -> Automatic,
  GridLinesStyle -> Directive[Gray, Dashed]
];

SetOptions[ListPlot,
  BaseStyle -> {FontFamily -> "Times", FontSize -> 12},
  FrameStyle -> Directive[Black, Thick],
  GridLines -> Automatic,
  GridLinesStyle -> Directive[Gray, Dashed]
];

(* Figure 1: Regge Trajectory Plot *)
reggePlot = Module[{data, fitLine, outliers, inliers},
  data = getStates[];
  
  (* Separate outliers and inliers *)
  outliers = Select[data, Abs[#["regge_residual"]] > 1.0 &];
  inliers = Select[data, Abs[#["regge_residual"]] <= 1.0 &];
  
  (* Create fit line *)
  fitLine = Plot[reggeFit[x], {x, Min[data[[All, "m2_gev2"]]], Max[data[[All, "m2_gev2"]]]}, 
    PlotStyle -> {Red, Thick}, PlotRange -> All];
  
  (* Create the plot *)
  Show[
    (* Inliers *)
    ListPlot[{{#["m2_gev2"], #["j"]}} & /@ inliers,
      PlotStyle -> {Blue, PointSize[0.02]},
      PlotLegends -> {"Data Points"}],
    
    (* Outliers *)
    ListPlot[{{#["m2_gev2"], #["j"]}} & /@ outliers,
      PlotStyle -> {Red, PointSize[0.03], PointSize[0.02]},
      PlotLegends -> {"Outliers"}],
    
    (* Fit line *)
    fitLine,
    
    (* Labels and styling *)
    Frame -> True,
    FrameLabel -> {"M² (GeV²)", "J"},
    PlotLabel -> Style["Regge Trajectory with Outliers Highlighted", Bold, 14],
    PlotRange -> All,
    AspectRatio -> 1/GoldenRatio
  ]
];

(* Figure 2: Residuals vs Hypergraph Features *)
residualsVsFeatures = Module[{data, absResiduals},
  data = getStates[];
  absResiduals = Abs[data[[All, "regge_residual"]]];
  
  GraphicsGrid[{
    {
      (* Residuals vs Product Entropy *)
      ListPlot[Transpose[{data[[All, "product_entropy"]], absResiduals}],
        PlotStyle -> {Blue, PointSize[0.02]},
        Frame -> True,
        FrameLabel -> {"Product Entropy", "|Residual|"},
        PlotLabel -> "Residuals vs Product Entropy",
        PlotRange -> All],
      
      (* Residuals vs Community Purity *)
      ListPlot[Transpose[{data[[All, "community_purity"]], absResiduals}],
        PlotStyle -> {Green, PointSize[0.02]},
        Frame -> True,
        FrameLabel -> {"Community Purity", "|Residual|"},
        PlotLabel -> "Residuals vs Community Purity",
        PlotRange -> All]
    },
    {
      (* Residuals vs Width *)
      ListPlot[Transpose[{data[[All, "width_gev"]], absResiduals}],
        PlotStyle -> {Red, PointSize[0.02]},
        Frame -> True,
        FrameLabel -> {"Width (GeV)", "|Residual|"},
        PlotLabel -> "Residuals vs Width",
        PlotRange -> All],
      
      (* Residuals vs Degree *)
      ListPlot[Transpose[{data[[All, "degree"]], absResiduals}],
        PlotStyle -> {Purple, PointSize[0.02]},
        Frame -> True,
        FrameLabel -> {"Degree", "|Residual|"},
        PlotLabel -> "Residuals vs Degree",
        PlotRange -> All]
    }
  }, ImageSize -> 800]
];

(* Figure 3: Hypothesis Test Summary *)
hypothesisSummary = Module[{supported, total, results},
  supported = getHypothesisCount[];
  total = Length[hypothesisResults];
  results = Table[
    {hyp, 
     If[isHypothesisSupported[hyp], "Supported", "Not Supported"],
     getCorrelation[StringReplace[hyp, "H1_quality_control" -> "width_vs_residual"]]},
    {hyp, Keys[hypothesisResults]}
  ];
  
  Grid[{
    {"Hypothesis", "Status", "Key Correlation"},
    Sequence @@ results
  }, 
  Frame -> All,
  Background -> {None, {LightBlue, LightGray}},
  Alignment -> Left]
];

(* Figure 4: Predictions with Confidence *)
predictionsPlot = Module[{predData, highConf, medConf, lowConf},
  predData = getPredictions[];
  
  (* Separate by confidence *)
  highConf = Select[predData, #["confidence"] == "high" &];
  medConf = Select[predData, #["confidence"] == "medium" &];
  lowConf = Select[predData, #["confidence"] == "low" &];
  
  (* Create plot *)
  Show[
    (* High confidence predictions *)
    ListPlot[{{#["J"], #["predicted_mass_gev"]}} & /@ highConf,
      PlotStyle -> {Green, PointSize[0.03]},
      PlotLegends -> {"High Confidence"}],
    
    (* Medium confidence predictions *)
    ListPlot[{{#["J"], #["predicted_mass_gev"]}} & /@ medConf,
      PlotStyle -> {Orange, PointSize[0.03]},
      PlotLegends -> {"Medium Confidence"}],
    
    (* Low confidence predictions *)
    ListPlot[{{#["J"], #["predicted_mass_gev"]}} & /@ lowConf,
      PlotStyle -> {Red, PointSize[0.03]},
      PlotLegends -> {"Low Confidence"}],
    
    (* Error bars *)
    ErrorBarPlot[{{#["J"], #["predicted_mass_gev"], #["mass_window_gev"]}} & /@ predData,
      PlotStyle -> {Gray, Thin}],
    
    (* Labels and styling *)
    Frame -> True,
    FrameLabel -> {"J", "Predicted Mass (GeV)"},
    PlotLabel -> Style["Predictions with Hypergraph-Informed Confidence", Bold, 14],
    PlotRange -> All,
    AspectRatio -> 1/GoldenRatio
  ]
];

(* Export all plots *)
Export["regge_trajectory_plot.pdf", reggePlot, ImageResolution -> 300];
Export["residuals_vs_features.pdf", residualsVsFeatures, ImageResolution -> 300];
Export["hypothesis_summary.pdf", hypothesisSummary, ImageResolution -> 300];
Export["predictions_plot.pdf", predictionsPlot, ImageResolution -> 300];

Print["All plots exported to PDF format with 300 DPI resolution."];
