"""
Mathematica Integration Module

Exports unified analysis results to Mathematica-compatible formats
for high-quality plotting and further analysis.
"""

import numpy as np
import pandas as pd
import json
from pathlib import Path
from typing import Dict, Any, List
import warnings
warnings.filterwarnings('ignore')

class MathematicaExporter:
    """
    Exports unified analysis results to Mathematica-compatible formats.
    """
    
    def __init__(self, output_dir: str = "mathematica_exports"):
        """
        Initialize Mathematica exporter.
        
        Parameters:
        -----------
        output_dir : str
            Directory for Mathematica export files
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        
    def export_unified_data_model(self, states_df: pd.DataFrame) -> Dict[str, str]:
        """
        Export unified data model to Mathematica-compatible formats.
        
        Parameters:
        -----------
        states_df : pd.DataFrame
            Unified states dataframe with all features
            
        Returns:
        --------
        Dict[str, str]
            Dictionary mapping export types to file paths
        """
        print("Exporting unified data model to Mathematica...")
        
        export_files = {}
        
        # 1. Export as JSON (Mathematica can read this easily)
        json_file = self.output_dir / "unified_states.json"
        
        # Convert DataFrame to JSON-friendly format
        json_data = {
            "metadata": {
                "description": "Unified Regge-Hypergraph Analysis Data Model",
                "n_states": len(states_df),
                "columns": list(states_df.columns),
                "families": states_df['family'].unique().tolist()
            },
            "data": states_df.to_dict('records')
        }
        
        with open(json_file, 'w') as f:
            json.dump(json_data, f, indent=2, default=str)
        
        export_files['json'] = str(json_file)
        
        # 2. Export as CSV (Mathematica can import this)
        csv_file = self.output_dir / "unified_states.csv"
        states_df.to_csv(csv_file, index=False)
        export_files['csv'] = str(csv_file)
        
        # 3. Export as Mathematica Association format
        mma_file = self.output_dir / "unified_states.m"
        
        with open(mma_file, 'w') as f:
            f.write("(* Unified Regge-Hypergraph Analysis Data Model *)\n")
            f.write("(* Generated by Python unified analysis framework *)\n\n")
            
            # Write metadata
            f.write("unifiedData = <|\n")
            f.write(f'  "metadata" -> <|\n')
            f.write(f'    "description" -> "Unified Regge-Hypergraph Analysis Data Model",\n')
            f.write(f'    "n_states" -> {len(states_df)},\n')
            f.write(f'    "families" -> {{{", ".join([f'"{fam}"' for fam in states_df["family"].unique()])}}},\n')
            f.write(f'    "generated_by" -> "Python Unified Analysis Framework"\n')
            f.write(f'  |>,\n')
            
            # Write data as list of associations
            f.write(f'  "states" -> {{\n')
            
            for idx, row in states_df.iterrows():
                f.write(f'    <|\n')
                f.write(f'      "id" -> "{row["id"]}",\n')
                f.write(f'      "name" -> "{row["name"]}",\n')
                f.write(f'      "family" -> "{row["family"]}",\n')
                f.write(f'      "j" -> {row["j"]},\n')
                f.write(f'      "p" -> {row["p"]},\n')
                f.write(f'      "mass_gev" -> {row["mass_gev"]},\n')
                f.write(f'      "mass_sigma_gev" -> {row["mass_sigma_gev"]},\n')
                f.write(f'      "m2_gev2" -> {row["m2_gev2"]},\n')
                f.write(f'      "m2_sigma_gev2" -> {row["m2_sigma_gev2"]},\n')
                f.write(f'      "pdg_status" -> "{row["pdg_status"]}",\n')
                f.write(f'      "width_gev" -> {row["width_gev"]},\n')
                f.write(f'      "community_id" -> {row["community_id"] if pd.notna(row["community_id"]) else "Null"},\n')
                f.write(f'      "community_purity" -> {row["community_purity"] if pd.notna(row["community_purity"]) else "Null"},\n')
                f.write(f'      "degree" -> {row["degree"] if pd.notna(row["degree"]) else "Null"},\n')
                f.write(f'      "product_entropy" -> {row["product_entropy"] if pd.notna(row["product_entropy"]) else "Null"},\n')
                f.write(f'      "cycle_count" -> {row["cycle_count"] if pd.notna(row["cycle_count"]) else "Null"},\n')
                f.write(f'      "clustering_coefficient" -> {row["clustering_coefficient"] if pd.notna(row["clustering_coefficient"]) else "Null"},\n')
                f.write(f'      "assortativity" -> {row["assortativity"] if pd.notna(row["assortativity"]) else "Null"},\n')
                f.write(f'      "regge_residual" -> {row["regge_residual"] if pd.notna(row["regge_residual"]) else "Null"},\n')
                f.write(f'      "regge_leverage" -> {row["regge_leverage"] if pd.notna(row["regge_leverage"]) else "Null"},\n')
                f.write(f'      "regge_influence" -> {row["regge_influence"] if pd.notna(row["regge_influence"]) else "Null"},\n')
                f.write(f'      "excluded_from_fit" -> {str(row["excluded_from_fit"]).lower()}\n')
                f.write(f'    |>')
                if idx < len(states_df) - 1:
                    f.write(',')
                f.write('\n')
            
            f.write(f'  }}\n')
            f.write(f'|>;\n\n')
            
            # Add helper functions
            f.write("(* Helper functions for data access *)\n")
            f.write("getStates[] := unifiedData[\"states\"];\n")
            f.write("getMetadata[] := unifiedData[\"metadata\"];\n")
            f.write("getFamily[family_] := Select[getStates[], #[\"family\"] == family &];\n")
            f.write("getOutliers[threshold_] := Select[getStates[], Abs[#[\"regge_residual\"]] > threshold &];\n")
        
        export_files['mathematica'] = str(mma_file)
        
        print(f"Exported unified data model to {len(export_files)} formats")
        return export_files
    
    def export_regge_fit_results(self, fit_results: Dict[str, Any]) -> Dict[str, str]:
        """
        Export Regge fit results to Mathematica.
        
        Parameters:
        -----------
        fit_results : Dict[str, Any]
            Results from Regge trajectory fitting
            
        Returns:
        --------
        Dict[str, str]
            Dictionary mapping export types to file paths
        """
        print("Exporting Regge fit results to Mathematica...")
        
        # Export as Mathematica notebook
        mma_file = self.output_dir / "regge_fit_results.m"
        
        with open(mma_file, 'w') as f:
            f.write("(* Regge Trajectory Fit Results *)\n")
            f.write("(* Generated by Python unified analysis framework *)\n\n")
            
            # Write fit parameters
            f.write("reggeFitResults = <|\n")
            f.write(f'  "parameters" -> {{{fit_results["parameters"][0]:.6f}, {fit_results["parameters"][1]:.6f}}},\n')
            f.write(f'  "parameter_uncertainties" -> {{{fit_results["parameter_uncertainties"][0]:.6f}, {fit_results["parameter_uncertainties"][1]:.6f}}},\n')
            f.write(f'  "chi2_dof" -> {fit_results["chi2_dof"]:.6f},\n')
            f.write(f'  "r_squared" -> {fit_results["r_squared"]:.6f},\n')
            f.write(f'  "fit_function" -> Function[x, {fit_results["parameters"][0]:.6f} + {fit_results["parameters"][1]:.6f} * x],\n')
            f.write(f'  "alpha0" -> {fit_results["parameters"][0]:.6f},\n')
            f.write(f'  "alphap" -> {fit_results["parameters"][1]:.6f}\n')
            f.write("|>;\n\n")
            
            # Add helper functions
            f.write("(* Helper functions for Regge analysis *)\n")
            f.write("reggeFit[x_] := reggeFitResults[\"fit_function\"][x];\n")
            f.write("getAlpha0[] := reggeFitResults[\"alpha0\"];\n")
            f.write("getAlphap[] := reggeFitResults[\"alphap\"];\n")
            f.write("getChi2Dof[] := reggeFitResults[\"chi2_dof\"];\n")
            f.write("getRSquared[] := reggeFitResults[\"r_squared\"];\n")
        
        return {'mathematica': str(mma_file)}
    
    def export_bridging_analysis_results(self, bridging_results: Dict[str, Any]) -> Dict[str, str]:
        """
        Export bridging analysis results to Mathematica.
        
        Parameters:
        -----------
        bridging_results : Dict[str, Any]
            Results from bridging analysis
            
        Returns:
        --------
        Dict[str, str]
            Dictionary mapping export types to file paths
        """
        print("Exporting bridging analysis results to Mathematica...")
        
        # Export as Mathematica notebook
        mma_file = self.output_dir / "bridging_analysis_results.m"
        
        with open(mma_file, 'w') as f:
            f.write("(* Bridging Analysis Results *)\n")
            f.write("(* Generated by Python unified analysis framework *)\n\n")
            
            # Write correlation results
            correlations = bridging_results['correlations']
            f.write("bridgingResults = <|\n")
            f.write('  "correlations" -> <|\n')
            
            for key, value in correlations.items():
                f.write(f'    "{key}" -> <|\n')
                f.write(f'      "correlation" -> {value["correlation"]:.6f},\n')
                f.write(f'      "p_value" -> {value["p_value"]:.6f}\n')
                f.write(f'    |>')
                if key != list(correlations.keys())[-1]:
                    f.write(',')
                f.write('\n')
            
            f.write('  |>,\n')
            
            # Write regression results
            regression = bridging_results['regression']
            f.write('  "regression" -> <|\n')
            f.write(f'    "r2" -> {regression["r2"]:.6f},\n')
            f.write(f'    "cv_r2_mean" -> {regression["cv_r2_mean"]:.6f},\n')
            f.write(f'    "cv_r2_std" -> {regression["cv_r2_std"]:.6f},\n')
            f.write(f'    "intercept" -> {regression["intercept"]:.6f},\n')
            f.write('    "coefficients" -> <|\n')
            
            for key, value in regression['coefficients'].items():
                f.write(f'      "{key}" -> {value:.6f}')
                if key != list(regression['coefficients'].keys())[-1]:
                    f.write(',')
                f.write('\n')
            
            f.write('    |>\n')
            f.write('  |>,\n')
            
            # Write predictive utility results
            predictive = bridging_results['predictive_utility']
            f.write('  "predictive_utility" -> <|\n')
            f.write(f'    "baseline_r2" -> {predictive["baseline_r2"]:.6f},\n')
            f.write(f'    "full_model_r2" -> {predictive["full_model_r2"]:.6f},\n')
            f.write(f'    "improvement" -> {predictive["improvement"]:.6f},\n')
            f.write(f'    "relative_improvement" -> {predictive["relative_improvement"]:.6f}\n')
            f.write('  |>\n')
            f.write('|>;\n\n')
            
            # Add helper functions
            f.write("(* Helper functions for bridging analysis *)\n")
            f.write("getCorrelation[feature_] := bridgingResults[\"correlations\"][feature][\"correlation\"];\n")
            f.write("getPValue[feature_] := bridgingResults[\"correlations\"][feature][\"p_value\"];\n")
            f.write("getRegressionR2[] := bridgingResults[\"regression\"][\"r2\"];\n")
            f.write("getImprovement[] := bridgingResults[\"predictive_utility\"][\"improvement\"];\n")
        
        return {'mathematica': str(mma_file)}
    
    def export_hypothesis_test_results(self, hypothesis_results: Dict[str, Any]) -> Dict[str, str]:
        """
        Export hypothesis test results to Mathematica.
        
        Parameters:
        -----------
        hypothesis_results : Dict[str, Any]
            Results from hypothesis testing
            
        Returns:
        --------
        Dict[str, str]
            Dictionary mapping export types to file paths
        """
        print("Exporting hypothesis test results to Mathematica...")
        
        # Export as Mathematica notebook
        mma_file = self.output_dir / "hypothesis_test_results.m"
        
        with open(mma_file, 'w') as f:
            f.write("(* Hypothesis Test Results *)\n")
            f.write("(* Generated by Python unified analysis framework *)\n\n")
            
            f.write("hypothesisResults = <|\n")
            
            for hypothesis, results in hypothesis_results.items():
                f.write(f'  "{hypothesis}" -> <|\n')
                f.write(f'    "supported" -> {str(results["supported"]).lower()},\n')
                
                # Write specific results for each hypothesis
                if hypothesis == 'H1_quality_control':
                    f.write(f'    "width_correlation" -> {results["width_correlation"]:.6f},\n')
                    f.write(f'    "width_p_value" -> {results["width_p_value"]:.6f},\n')
                    f.write(f'    "status_correlation" -> {results["status_correlation"]:.6f},\n')
                    f.write(f'    "status_p_value" -> {results["status_p_value"]:.6f}\n')
                elif hypothesis == 'H2_structure_deviation':
                    f.write(f'    "entropy_correlation" -> {results["entropy_correlation"]:.6f},\n')
                    f.write(f'    "entropy_p_value" -> {results["entropy_p_value"]:.6f},\n')
                    f.write(f'    "purity_correlation" -> {results["purity_correlation"]:.6f},\n')
                    f.write(f'    "purity_p_value" -> {results["purity_p_value"]:.6f}\n')
                elif hypothesis == 'H3_motifs':
                    f.write(f'    "triangle_correlation" -> {results["triangle_correlation"]:.6f},\n')
                    f.write(f'    "triangle_p_value" -> {results["triangle_p_value"]:.6f}\n')
                elif hypothesis == 'H4_predictive_gain':
                    f.write(f'    "absolute_improvement" -> {results["absolute_improvement"]:.6f},\n')
                    f.write(f'    "relative_improvement" -> {results["relative_improvement"]:.6f}\n')
                
                f.write(f'  |>')
                if hypothesis != list(hypothesis_results.keys())[-1]:
                    f.write(',')
                f.write('\n')
            
            f.write('|>;\n\n')
            
            # Add helper functions
            f.write("(* Helper functions for hypothesis testing *)\n")
            f.write("isHypothesisSupported[hypothesis_] := hypothesisResults[hypothesis][\"supported\"];\n")
            f.write("getSupportedHypotheses[] := Select[Keys[hypothesisResults], isHypothesisSupported[#] &];\n")
            f.write("getHypothesisCount[] := Count[Values[hypothesisResults], _[(\"supported\" -> True)]];\n")
        
        return {'mathematica': str(mma_file)}
    
    def export_predictions(self, predictions_df: pd.DataFrame) -> Dict[str, str]:
        """
        Export predictions to Mathematica.
        
        Parameters:
        -----------
        predictions_df : pd.DataFrame
            Predictions with hypergraph context
            
        Returns:
        --------
        Dict[str, str]
            Dictionary mapping export types to file paths
        """
        print("Exporting predictions to Mathematica...")
        
        # Export as Mathematica notebook
        mma_file = self.output_dir / "predictions.m"
        
        with open(mma_file, 'w') as f:
            f.write("(* Predictions with Hypergraph Context *)\n")
            f.write("(* Generated by Python unified analysis framework *)\n\n")
            
            f.write("predictions = {\n")
            
            for idx, row in predictions_df.iterrows():
                f.write(f'  <|\n')
                f.write(f'    "J" -> {row["J"]},\n')
                f.write(f'    "predicted_mass_gev" -> {row["predicted_mass_gev"]:.6f},\n')
                f.write(f'    "mass_window_gev" -> {row["mass_window_gev"]:.6f},\n')
                f.write(f'    "nearest_community" -> {row["nearest_community"]},\n')
                f.write(f'    "community_purity" -> {row["community_purity"]:.6f},\n')
                f.write(f'    "confidence" -> "{row["confidence"]}",\n')
                f.write(f'    "notes" -> "{row["notes"]}"\n')
                f.write(f'  |>')
                if idx < len(predictions_df) - 1:
                    f.write(',')
                f.write('\n')
            
            f.write('};\n\n')
            
            # Add helper functions
            f.write("(* Helper functions for predictions *)\n")
            f.write("getPredictions[] := predictions;\n")
            f.write("getHighConfidencePredictions[] := Select[predictions, #[\"confidence\"] == \"high\" &];\n")
            f.write("getPredictionsByJ[j_] := Select[predictions, #[\"J\"] == j &];\n")
            f.write("getPredictionMass[j_] := First[getPredictionsByJ[j]][\"predicted_mass_gev\"];\n")
        
        return {'mathematica': str(mma_file)}
    
    def create_mathematica_plotting_notebook(self) -> str:
        """
        Create a Mathematica notebook with plotting functions.
        
        Returns:
        --------
        str
            Path to the created notebook
        """
        print("Creating Mathematica plotting notebook...")
        
        notebook_file = self.output_dir / "unified_analysis_plots.nb"
        
        notebook_content = '''(* Unified Regge-Hypergraph Analysis Plots *)
(* Generated by Python unified analysis framework *)

(* Load the exported data *)
<< "unified_states.m"
<< "regge_fit_results.m"
<< "bridging_analysis_results.m"
<< "hypothesis_test_results.m"
<< "predictions.m"

(* Set up plotting styles *)
SetOptions[Plot, 
  BaseStyle -> {FontFamily -> "Times", FontSize -> 12},
  FrameStyle -> Directive[Black, Thick],
  GridLines -> Automatic,
  GridLinesStyle -> Directive[Gray, Dashed]
];

SetOptions[ListPlot,
  BaseStyle -> {FontFamily -> "Times", FontSize -> 12},
  FrameStyle -> Directive[Black, Thick],
  GridLines -> Automatic,
  GridLinesStyle -> Directive[Gray, Dashed]
];

(* Figure 1: Regge Trajectory Plot *)
reggePlot = Module[{data, fitLine, outliers, inliers},
  data = getStates[];
  
  (* Separate outliers and inliers *)
  outliers = Select[data, Abs[#["regge_residual"]] > 1.0 &];
  inliers = Select[data, Abs[#["regge_residual"]] <= 1.0 &];
  
  (* Create fit line *)
  fitLine = Plot[reggeFit[x], {x, Min[data[[All, "m2_gev2"]]], Max[data[[All, "m2_gev2"]]]}, 
    PlotStyle -> {Red, Thick}, PlotRange -> All];
  
  (* Create the plot *)
  Show[
    (* Inliers *)
    ListPlot[{{#["m2_gev2"], #["j"]}} & /@ inliers,
      PlotStyle -> {Blue, PointSize[0.02]},
      PlotLegends -> {"Data Points"}],
    
    (* Outliers *)
    ListPlot[{{#["m2_gev2"], #["j"]}} & /@ outliers,
      PlotStyle -> {Red, PointSize[0.03], PointSize[0.02]},
      PlotLegends -> {"Outliers"}],
    
    (* Fit line *)
    fitLine,
    
    (* Labels and styling *)
    Frame -> True,
    FrameLabel -> {"M² (GeV²)", "J"},
    PlotLabel -> Style["Regge Trajectory with Outliers Highlighted", Bold, 14],
    PlotRange -> All,
    AspectRatio -> 1/GoldenRatio
  ]
];

(* Figure 2: Residuals vs Hypergraph Features *)
residualsVsFeatures = Module[{data, absResiduals},
  data = getStates[];
  absResiduals = Abs[data[[All, "regge_residual"]]];
  
  GraphicsGrid[{
    {
      (* Residuals vs Product Entropy *)
      ListPlot[Transpose[{data[[All, "product_entropy"]], absResiduals}],
        PlotStyle -> {Blue, PointSize[0.02]},
        Frame -> True,
        FrameLabel -> {"Product Entropy", "|Residual|"},
        PlotLabel -> "Residuals vs Product Entropy",
        PlotRange -> All],
      
      (* Residuals vs Community Purity *)
      ListPlot[Transpose[{data[[All, "community_purity"]], absResiduals}],
        PlotStyle -> {Green, PointSize[0.02]},
        Frame -> True,
        FrameLabel -> {"Community Purity", "|Residual|"},
        PlotLabel -> "Residuals vs Community Purity",
        PlotRange -> All]
    },
    {
      (* Residuals vs Width *)
      ListPlot[Transpose[{data[[All, "width_gev"]], absResiduals}],
        PlotStyle -> {Red, PointSize[0.02]},
        Frame -> True,
        FrameLabel -> {"Width (GeV)", "|Residual|"},
        PlotLabel -> "Residuals vs Width",
        PlotRange -> All],
      
      (* Residuals vs Degree *)
      ListPlot[Transpose[{data[[All, "degree"]], absResiduals}],
        PlotStyle -> {Purple, PointSize[0.02]},
        Frame -> True,
        FrameLabel -> {"Degree", "|Residual|"},
        PlotLabel -> "Residuals vs Degree",
        PlotRange -> All]
    }
  }, ImageSize -> 800]
];

(* Figure 3: Hypothesis Test Summary *)
hypothesisSummary = Module[{supported, total, results},
  supported = getHypothesisCount[];
  total = Length[hypothesisResults];
  results = Table[
    {hyp, 
     If[isHypothesisSupported[hyp], "Supported", "Not Supported"],
     getCorrelation[StringReplace[hyp, "H1_quality_control" -> "width_vs_residual"]]},
    {hyp, Keys[hypothesisResults]}
  ];
  
  Grid[{
    {"Hypothesis", "Status", "Key Correlation"},
    Sequence @@ results
  }, 
  Frame -> All,
  Background -> {None, {LightBlue, LightGray}},
  Alignment -> Left]
];

(* Figure 4: Predictions with Confidence *)
predictionsPlot = Module[{predData, highConf, medConf, lowConf},
  predData = getPredictions[];
  
  (* Separate by confidence *)
  highConf = Select[predData, #["confidence"] == "high" &];
  medConf = Select[predData, #["confidence"] == "medium" &];
  lowConf = Select[predData, #["confidence"] == "low" &];
  
  (* Create plot *)
  Show[
    (* High confidence predictions *)
    ListPlot[{{#["J"], #["predicted_mass_gev"]}} & /@ highConf,
      PlotStyle -> {Green, PointSize[0.03]},
      PlotLegends -> {"High Confidence"}],
    
    (* Medium confidence predictions *)
    ListPlot[{{#["J"], #["predicted_mass_gev"]}} & /@ medConf,
      PlotStyle -> {Orange, PointSize[0.03]},
      PlotLegends -> {"Medium Confidence"}],
    
    (* Low confidence predictions *)
    ListPlot[{{#["J"], #["predicted_mass_gev"]}} & /@ lowConf,
      PlotStyle -> {Red, PointSize[0.03]},
      PlotLegends -> {"Low Confidence"}],
    
    (* Error bars *)
    ErrorBarPlot[{{#["J"], #["predicted_mass_gev"], #["mass_window_gev"]}} & /@ predData,
      PlotStyle -> {Gray, Thin}],
    
    (* Labels and styling *)
    Frame -> True,
    FrameLabel -> {"J", "Predicted Mass (GeV)"},
    PlotLabel -> Style["Predictions with Hypergraph-Informed Confidence", Bold, 14],
    PlotRange -> All,
    AspectRatio -> 1/GoldenRatio
  ]
];

(* Export all plots *)
Export["regge_trajectory_plot.pdf", reggePlot, ImageResolution -> 300];
Export["residuals_vs_features.pdf", residualsVsFeatures, ImageResolution -> 300];
Export["hypothesis_summary.pdf", hypothesisSummary, ImageResolution -> 300];
Export["predictions_plot.pdf", predictionsPlot, ImageResolution -> 300];

Print["All plots exported to PDF format with 300 DPI resolution."];
'''
        
        with open(notebook_file, 'w') as f:
            f.write(notebook_content)
        
        return str(notebook_file)
    
    def export_all_results(self, unified_analyzer, hypothesis_results: Dict[str, Any], 
                          bridging_results: Dict[str, Any], predictions_df: pd.DataFrame) -> Dict[str, str]:
        """
        Export all unified analysis results to Mathematica.
        
        Parameters:
        -----------
        unified_analyzer : UnifiedAnalyzer
            The unified analyzer instance
        hypothesis_results : Dict[str, Any]
            Results from hypothesis testing
        bridging_results : Dict[str, Any]
            Results from bridging analysis
        predictions_df : pd.DataFrame
            Predictions with hypergraph context
            
        Returns:
        --------
        Dict[str, str]
            Dictionary mapping export types to file paths
        """
        print("Exporting all results to Mathematica...")
        
        all_exports = {}
        
        # Export unified data model
        data_exports = self.export_unified_data_model(unified_analyzer.states_df)
        all_exports.update(data_exports)
        
        # Export Regge fit results (if available)
        if hasattr(unified_analyzer, 'fit_results'):
            regge_exports = self.export_regge_fit_results(unified_analyzer.fit_results)
            all_exports.update(regge_exports)
        
        # Export bridging analysis results
        bridging_exports = self.export_bridging_analysis_results(bridging_results)
        all_exports.update(bridging_exports)
        
        # Export hypothesis test results
        hypothesis_exports = self.export_hypothesis_test_results(hypothesis_results)
        all_exports.update(hypothesis_exports)
        
        # Export predictions
        prediction_exports = self.export_predictions(predictions_df)
        all_exports.update(prediction_exports)
        
        # Create plotting notebook
        notebook_file = self.create_mathematica_plotting_notebook()
        all_exports['plotting_notebook'] = notebook_file
        
        # Create README for Mathematica usage
        readme_file = self.output_dir / "README_Mathematica.md"
        with open(readme_file, 'w') as f:
            f.write("# Mathematica Integration Guide\n\n")
            f.write("This directory contains all exported data and plotting functions for Mathematica analysis.\n\n")
            f.write("## Files:\n\n")
            f.write("- `unified_states.m`: Main data model with all particle states and features\n")
            f.write("- `regge_fit_results.m`: Regge trajectory fit parameters and diagnostics\n")
            f.write("- `bridging_analysis_results.m`: Statistical analysis linking hypergraph features to Regge residuals\n")
            f.write("- `hypothesis_test_results.m`: Results from pre-registered hypothesis tests\n")
            f.write("- `predictions.m`: Predictions with hypergraph-informed confidence levels\n")
            f.write("- `unified_analysis_plots.nb`: Mathematica notebook with publication-quality plotting functions\n\n")
            f.write("## Usage:\n\n")
            f.write("1. Open `unified_analysis_plots.nb` in Mathematica\n")
            f.write("2. Run the notebook to generate publication-quality plots\n")
            f.write("3. All plots are automatically exported as high-resolution PDFs\n\n")
            f.write("## Key Functions:\n\n")
            f.write("- `getStates[]`: Access all particle data\n")
            f.write("- `reggeFit[x]`: Regge trajectory fit function\n")
            f.write("- `getCorrelation[feature]`: Get correlation coefficient for a feature\n")
            f.write("- `isHypothesisSupported[hypothesis]`: Check if a hypothesis is supported\n")
            f.write("- `getPredictions[]`: Access predictions with confidence levels\n")
        
        all_exports['readme'] = str(readme_file)
        
        print(f"Exported {len(all_exports)} files to Mathematica-compatible formats")
        return all_exports

if __name__ == "__main__":
    print("Mathematica Integration Module")
    print("Use this module to export unified analysis results to Mathematica for plotting.")
